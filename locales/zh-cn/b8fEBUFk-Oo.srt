1
00:00:00,000 --> 00:00:06,839
让我们隐藏这些类的内部代码来对比它们构建方式

2
00:00:07,259 --> 00:00:11,689
请记住这里有一个新的特殊方法叫做 constructor

3
00:00:11,689 --> 00:00:15,189
无论什么时候调用该类 constructor 都会运行

4
00:00:15,189 --> 00:00:19,214
它和这里的 Tree 构造器做相同的事情

5
00:00:19,214 --> 00:00:21,469
还要记住 类定义中 (添加) 一个方法名

6
00:00:21,469 --> 00:00:26,179
和在原型中添加该方法是等价的

7
00:00:26,179 --> 00:00:29,929
对于基类这看起来十分的相似

8
00:00:29,929 --> 00:00:33,920
当基类扩展到子类时 区别就会明显的多

9
00:00:33,920 --> 00:00:35,825
对于旧版本的 ES5 代码

10
00:00:35,825 --> 00:00:39,210
我们必须创建另一个构造函数

11
00:00:39,210 --> 00:00:44,740
然后将这个函数的原型设置为基类原型

12
00:00:44,740 --> 00:00:47,704
因为我们重写了初始的原型对象

13
00:00:47,704 --> 00:00:49,640
所以我们需要重新建立 constructor 属性

14
00:00:49,640 --> 00:00:53,314
和初始构造函数之间的连接

15
00:00:53,314 --> 00:00:58,629
接着让我们回复常态 在原型对象上添加方法

16
00:00:58,630 --> 00:01:01,490
现在让我们比较全部的代码 它使得这两个函数相互连接

17
00:01:01,490 --> 00:01:05,625
并让原型和这部分代码链接起来

18
00:01:05,625 --> 00:01:07,909
这只是另一种类定义的方式

19
00:01:07,909 --> 00:01:12,575
只是使用了 extends 关键字来连接 Maple 类和基类

20
00:01:12,575 --> 00:01:14,484
太棒了 对吗

21
00:01:14,484 --> 00:01:18,183
同时从子类中调用基类也变得更容易了

22
00:01:18,183 --> 00:01:21,894
ES6 代码使用了新的 super 关键字

23
00:01:21,894 --> 00:01:29,368
在 ES5 中你需要使用 .call 并将 "this" 作为第一个参数传入

24
00:01:35,859 --> 00:01:42,180
在新的类格式中 使用更少的代码就能调用原型中的方法
